<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <title>Phong + Niebla + Agua + Skybox (WebGL2)</title>

    <style>
        body {
            background: #222;
            color: white;
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 2px solid white;
            width: 600px;
            height: 600px;
        }
        
        h2 {
            margin-bottom: 10px;
        }
        
        .info {
            margin-top: 10px;
            color: #aaa;
            font-size: 14px;
        }
        
        /* Ocultar las imágenes del skybox pero mantenerlas cargadas */
        .skybox-images {
            display: none;
        }
    </style>

    <!-- Imágenes del Skybox -->
    <div class="skybox-images">
        <img id="skybox_px" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/px.jpg" crossorigin="anonymous">
        <img id="skybox_nx" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/nx.jpg" crossorigin="anonymous">
        <img id="skybox_py" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/py.jpg" crossorigin="anonymous">
        <img id="skybox_ny" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/ny.jpg" crossorigin="anonymous">
        <img id="skybox_pz" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/pz.jpg" crossorigin="anonymous">
        <img id="skybox_nz" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/nz.jpg" crossorigin="anonymous">
    </div>

    <!-- ================= VERTEX SHADER ================= -->
    <script id="vs" type="text/plain">
#version 300 es
precision mediump float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

uniform float uTime;     // tiempo (niebla + agua)
uniform float isWater;   // 0.0 = cubo | 1.0 = agua
uniform float isSkybox;  // 1.0 = skybox, 0.0 = otros objetos

in vec3 VertexPosition;
in vec3 VertexNormal;
in vec2 VertexTexCoord;  // Para todos los objetos

out vec3 ecPositionOut;
out vec3 ecNormalOut;
out vec2 TexCoordOut;
out vec3 skyboxTexCoord; // Coordenadas 3D para el cubemap

void main() {
    // ===== SKYBOX (renderizado especial) =====
    if (isSkybox > 0.5) {
        TexCoordOut = VertexTexCoord;
        // Usar la posición como coordenada de textura para el cubemap
        skyboxTexCoord = VertexPosition;
        
        // Eliminar la traslación de la matriz de vista para que el skybox siempre esté centrado
        vec4 pos = projectionMatrix * mat4(mat3(modelViewMatrix)) * vec4(VertexPosition, 1.0);
        gl_Position = pos.xyww;  // Usar .xyww para asegurar z = 1.0 (más lejano)
        ecPositionOut = vec3(0.0);
        ecNormalOut = vec3(0.0);
        return;
    }

    // ===== POSICIÓN BASE (CUBO Y AGUA) =====
    vec3 pos = VertexPosition;
    vec3 normal = VertexNormal;

    // ===== AGUA (DISPLACEMENT MAPPING) =====
    if (isWater > 0.5) {
        float w1 = sin(pos.x * 2.5 + uTime * 1.5);
        float w2 = cos(pos.z * 2.0 + uTime * 1.2);
        float w3 = sin((pos.x + pos.z) * 1.5 + uTime);

        float height = (w1 + w2 + w3) * 0.08;
        pos.y += height;

        normal = normalize(vec3(
            -cos(pos.x * 2.5 + uTime * 1.5) * 2.5 * 0.08,
             1.0,
            -sin(pos.z * 2.0 + uTime * 1.2) * 2.0 * 0.08
        ));
    }

    vec4 ecPosition = modelViewMatrix * vec4(pos, 1.0);
    ecPositionOut = vec3(ecPosition);
    ecNormalOut = normalize(normalMatrix * normal);
    TexCoordOut = VertexTexCoord;
    skyboxTexCoord = vec3(0.0); // Valor por defecto

    gl_Position = projectionMatrix * ecPosition;
}
    </script>

    <!-- ================= FRAGMENT SHADER ================= -->
    <script id="fs" type="text/plain">
#version 300 es
precision mediump float;

in vec3 ecPositionOut;
in vec3 ecNormalOut;
in vec2 TexCoordOut;
in vec3 skyboxTexCoord; // Coordenadas 3D para el cubemap
out vec4 fragmentColor;

struct LightData {
    vec3 Position;
    vec3 La;
    vec3 Ld;
    vec3 Ls;
};
uniform LightData Light;

struct MaterialData {
    vec3 Ka;
    vec3 Kd;
    vec3 Ks;
    float alpha;
};
uniform MaterialData Material;

/* ================= NIEBLA ================= */
uniform float fogMin;
uniform float fogMax;
uniform vec3 fogColor;
uniform float fogEnabled;
uniform float fogMode;
uniform float uTime;
uniform float isSkybox;

// Textura del skybox (ahora es un samplerCube)
uniform samplerCube skyboxTexture;
uniform float skyboxRotation;  // Rotación del skybox

vec3 phong(vec3 N, vec3 L, vec3 V) {
    vec3 ambient = Material.Ka * Light.La;
    float NdotL = max(dot(N, L), 0.0);
    vec3 diffuse = NdotL * (Light.Ld * Material.Kd);
    vec3 specular = vec3(0.0);

    if (NdotL > 0.0) {
        vec3 H = normalize(L + V);
        float NdotH = max(dot(N, H), 0.0);
        specular = pow(NdotH, Material.alpha) * (Light.Ls * Material.Ks);
    }
    return ambient + diffuse + specular;
}

// Función para crear un gradiente de cielo procedural
vec3 skyGradient(vec3 direction) {
    float horizon = 0.1;
    float zenith = 1.0;
    
    // Normalizar la dirección Y para el gradiente
    float t = clamp((direction.y + 1.0) * 0.5, 0.0, 1.0);
    
    // Colores del cielo
    vec3 horizonColor = vec3(0.5, 0.7, 1.0);    // Azul claro
    vec3 zenithColor = vec3(0.1, 0.2, 0.5);     // Azul oscuro
    
    // Mezclar según la altura
    vec3 skyColor = mix(horizonColor, zenithColor, t);
    
    // Añadir nubes procedurales
    vec2 uv = vec2(
        atan(direction.x, direction.z) / (2.0 * 3.14159),
        asin(direction.y) / 3.14159 + 0.5
    );
    
    // Patrón de nubes simple
    float cloud = sin(uv.x * 10.0 + uTime * 0.2) * 
                  sin(uv.y * 5.0 + uTime * 0.3) * 
                  sin((uv.x + uv.y) * 7.0 + uTime * 0.1);
    
    cloud = smoothstep(0.2, 0.8, cloud * 0.5 + 0.5);
    skyColor = mix(skyColor, vec3(1.0), cloud * 0.3);
    
    return skyColor;
}

void main() {
    // ===== SKYBOX =====
    if (isSkybox > 0.5) {
        vec3 dir = normalize(skyboxTexCoord);
        
        // Aplicar rotación alrededor del eje Y
        float cosRot = cos(skyboxRotation);
        float sinRot = sin(skyboxRotation);
        vec3 rotatedDir = vec3(
            cosRot * dir.x - sinRot * dir.z,
            dir.y,
            sinRot * dir.x + cosRot * dir.z
        );
        
        // Usar cielo procedural
        vec3 skyColor = skyGradient(rotatedDir);
        
        // Añadir estrellas en la noche
        float nightFactor = smoothstep(-0.2, 0.0, rotatedDir.y);
        if (nightFactor > 0.0) {
            // Generar estrellas procedurales
            float star = fract(sin(dot(rotatedDir, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);
            if (star > 0.995) {
                skyColor = mix(skyColor, vec3(1.0), 0.8 * nightFactor);
            }
        }
        
        fragmentColor = vec4(skyColor, 1.0);
        return;
    }

    // ===== OBJETOS NORMALES (cubo y agua) =====
    vec3 N = normalize(ecNormalOut);
    vec3 V = normalize(-ecPositionOut);
    vec3 L = normalize(Light.Position - ecPositionOut);

    vec3 litColor = phong(N, L, V);

    if (fogEnabled < 0.5) {
        fragmentColor = vec4(litColor, 1.0);
        return;
    }

    float dist = abs(ecPositionOut.z);

    float drift = ecPositionOut.x * 1.8 + ecPositionOut.y * 1.0 + uTime * 1.8;
    float bank = 0.5 + 0.5 * sin(drift);
    bank = pow(bank, 3.0);
    dist += bank * 2.5;

    float fogFactor;
    if (fogMode < 0.5) {
        fogFactor = (fogMax - dist) / (fogMax - fogMin);
    } else {
        float dnorm = clamp((dist - fogMin) / (fogMax - fogMin), 0.0, 1.0);
        fogFactor = exp(-pow(dnorm * 3.0, 2.0));
    }

    fogFactor = clamp(fogFactor, 0.0, 1.0);
    vec3 finalColor = mix(fogColor, litColor, fogFactor);
    fragmentColor = vec4(finalColor, 1.0);
}
    </script>

</head>

<body>
    <h2>Phong + Niebla + Agua + Skybox</h2>
    <canvas id="glCanvas" width="600" height="600"></canvas>
    <div class="info">Arrastra con el ratón para rotar la cámara</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
    <script src="app.js"></script>
</body>
</html>