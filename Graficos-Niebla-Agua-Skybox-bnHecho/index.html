<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <title>Phong + Niebla + Agua + Skybox Mejorado (WebGL2)</title>

    <style>
        body {
            background: #222;
            color: white;
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            border: 2px solid white;
            width: 600px;
            height: 600px;
        }
        
        h2 {
            margin-bottom: 10px;
        }
        
        .info {
            margin-top: 10px;
            color: #aaa;
            font-size: 14px;
        }
        
        /* Ocultar las imágenes del skybox pero mantenerlas cargadas */
        .skybox-images {
            display: none;
        }
    </style>

    <!-- Imágenes del Skybox -->
    <div class="skybox-images">
        <img id="skybox_px" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/px.jpg" crossorigin="anonymous">
        <img id="skybox_nx" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/nx.jpg" crossorigin="anonymous">
        <img id="skybox_py" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/py.jpg" crossorigin="anonymous">
        <img id="skybox_ny" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/ny.jpg" crossorigin="anonymous">
        <img id="skybox_pz" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/pz.jpg" crossorigin="anonymous">
        <img id="skybox_nz" src="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/SwedishRoyalCastle/nz.jpg" crossorigin="anonymous">
    </div>

    <!-- ================= VERTEX SHADER ================= -->
    <script id="vs" type="text/plain">
#version 300 es
precision mediump float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

uniform float uTime;     // tiempo (niebla + agua)
uniform float isWater;   // 0.0 = cubo | 1.0 = agua
uniform float isSkybox;  // 1.0 = skybox, 0.0 = otros objetos

in vec3 VertexPosition;
in vec3 VertexNormal;
in vec2 VertexTexCoord;  // Para todos los objetos

out vec3 ecPositionOut;
out vec3 ecNormalOut;
out vec2 TexCoordOut;
out vec3 skyboxTexCoord; // Coordenadas 3D para el cubemap

void main() {
    // ===== SKYBOX (renderizado especial) =====
    if (isSkybox > 0.5) {
        TexCoordOut = VertexTexCoord;
        // Usar la posición como coordenada de textura para el cubemap
        skyboxTexCoord = VertexPosition;
        
        // Eliminar la traslación de la matriz de vista para que el skybox siempre esté centrado
        vec4 pos = projectionMatrix * mat4(mat3(modelViewMatrix)) * vec4(VertexPosition, 1.0);
        gl_Position = pos.xyww;  // Usar .xyww para asegurar z = 1.0 (más lejano)
        ecPositionOut = vec3(0.0);
        ecNormalOut = vec3(0.0);
        return;
    }

    // ===== POSICIÓN BASE (CUBO Y AGUA) =====
    vec3 pos = VertexPosition;
    vec3 normal = VertexNormal;

    // ===== AGUA (DISPLACEMENT MAPPING) =====
    if (isWater > 0.5) {
        float w1 = sin(pos.x * 2.5 + uTime * 1.5);
        float w2 = cos(pos.z * 2.0 + uTime * 1.2);
        float w3 = sin((pos.x + pos.z) * 1.5 + uTime);

        float height = (w1 + w2 + w3) * 0.08;
        pos.y += height;

        normal = normalize(vec3(
            -cos(pos.x * 2.5 + uTime * 1.5) * 2.5 * 0.08,
             1.0,
            -sin(pos.z * 2.0 + uTime * 1.2) * 2.0 * 0.08
        ));
    }

    vec4 ecPosition = modelViewMatrix * vec4(pos, 1.0);
    ecPositionOut = vec3(ecPosition);
    ecNormalOut = normalize(normalMatrix * normal);
    TexCoordOut = VertexTexCoord;
    skyboxTexCoord = vec3(0.0); // Valor por defecto

    gl_Position = projectionMatrix * ecPosition;
}
    </script>

    <!-- ================= FRAGMENT SHADER ================= -->
    <script id="fs" type="text/plain">
#version 300 es
precision mediump float;

in vec3 ecPositionOut;
in vec3 ecNormalOut;
in vec2 TexCoordOut;
in vec3 skyboxTexCoord; // Coordenadas 3D para el cubemap
out vec4 fragmentColor;

struct LightData {
    vec3 Position;
    vec3 La;
    vec3 Ld;
    vec3 Ls;
};
uniform LightData Light;

struct MaterialData {
    vec3 Ka;
    vec3 Kd;
    vec3 Ks;
    float alpha;
};
uniform MaterialData Material;

/* ================= NIEBLA ================= */
uniform float fogMin;
uniform float fogMax;
uniform vec3 fogColor;
uniform float fogEnabled;
uniform float fogMode;
uniform float uTime;
uniform float isSkybox;

// Controles del cielo
uniform float cloudIntensity;
uniform float starIntensity;
uniform float skyBrightness;

// Textura del skybox (ahora es un samplerCube)
uniform samplerCube skyboxTexture;
uniform float skyboxRotation;  // Rotación del skybox

vec3 phong(vec3 N, vec3 L, vec3 V) {
    vec3 ambient = Material.Ka * Light.La;
    float NdotL = max(dot(N, L), 0.0);
    vec3 diffuse = NdotL * (Light.Ld * Material.Kd);
    vec3 specular = vec3(0.0);

    if (NdotL > 0.0) {
        vec3 H = normalize(L + V);
        float NdotH = max(dot(N, H), 0.0);
        specular = pow(NdotH, Material.alpha) * (Light.Ls * Material.Ks);
    }
    return ambient + diffuse + specular;
}

// Función de ruido para nubes más realistas
float hash(vec3 p) {
    p = fract(p * 0.3183099 + 0.1);
    p *= 17.0;
    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}

float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    
    return mix(
        mix(mix(hash(p + vec3(0,0,0)), hash(p + vec3(1,0,0)), f.x),
            mix(hash(p + vec3(0,1,0)), hash(p + vec3(1,1,0)), f.x), f.y),
        mix(mix(hash(p + vec3(0,0,1)), hash(p + vec3(1,0,1)), f.x),
            mix(hash(p + vec3(0,1,1)), hash(p + vec3(1,1,1)), f.x), f.y), f.z);
}

// Función para crear un gradiente de cielo procedural con nubes mejoradas
vec3 skyGradient(vec3 direction, float time) {
    float horizon = 0.1;
    float zenith = 1.0;
    
    // Normalizar la dirección Y para el gradiente
    float t = clamp((direction.y + 1.0) * 0.5, 0.0, 1.0);
    t = pow(t, 0.7); // Hacer el gradiente más pronunciado
    
    // Colores del cielo - más vibrantes
    vec3 horizonColor = vec3(0.6, 0.8, 1.0);    // Azul claro brillante
    vec3 zenithColor = vec3(0.05, 0.15, 0.4);   // Azul oscuro profundo
    
    // Mezclar según la altura
    vec3 skyColor = mix(horizonColor, zenithColor, t);
    
    // Coordenadas esféricas para las nubes
    vec2 uv = vec2(
        atan(direction.x, direction.z) / (2.0 * 3.14159),
        asin(direction.y) / 3.14159 + 0.5
    );
    
    // NUBES MEJORADAS - Múltiples capas de ruido
    float cloudTime = time * 0.15;
    
    // Capa 1 - Nubes grandes y suaves
    vec3 cloudCoord1 = direction * 1.5 + vec3(cloudTime * 0.3, 0.0, cloudTime * 0.2);
    float clouds1 = noise(cloudCoord1);
    clouds1 = smoothstep(0.3, 0.7, clouds1);
    
    // Capa 2 - Nubes medianas
    vec3 cloudCoord2 = direction * 3.0 + vec3(cloudTime * 0.5, 0.0, cloudTime * 0.3);
    float clouds2 = noise(cloudCoord2);
    clouds2 = smoothstep(0.4, 0.8, clouds2);
    
    // Capa 3 - Nubes pequeñas
    vec3 cloudCoord3 = direction * 6.0 + vec3(cloudTime * 0.7, 0.0, cloudTime * 0.4);
    float clouds3 = noise(cloudCoord3);
    clouds3 = smoothstep(0.5, 0.9, clouds3);
    
    // Combinar capas de nubes con intensidad ajustable
    float totalClouds = clouds1 * 0.5 + clouds2 * 0.3 + clouds3 * 0.2;
    totalClouds = clamp(totalClouds * 1.5 * cloudIntensity, 0.0, 1.0); // Aplicar intensidad
    
    // Hacer que las nubes sean más blancas y opacas
    vec3 cloudColor = vec3(1.0, 1.0, 1.0);
    float cloudOpacity = 0.8; // Más opacas
    
    // Mezclar nubes con el cielo - más prominentes
    skyColor = mix(skyColor, cloudColor, totalClouds * cloudOpacity);
    
    // Añadir brillo a los bordes de las nubes
    float cloudEdge = smoothstep(0.0, 0.3, totalClouds) * (1.0 - smoothstep(0.7, 1.0, totalClouds));
    skyColor += cloudColor * cloudEdge * 0.3;
    
    // Aplicar brillo general del cielo
    skyColor *= skyBrightness;
    
    return skyColor;
}

// Función para generar estrellas más visibles
float starField(vec3 direction, float time) {
    // Usar coordenadas esféricas para las estrellas
    vec2 uv = vec2(
        atan(direction.x, direction.z) / (2.0 * 3.14159),
        asin(direction.y) / 3.14159 + 0.5
    );
    
    // Generar patrón de estrellas con ruido
    float starNoise = fract(sin(dot(uv * 100.0, vec2(12.9898, 78.233))) * 43758.5453);
    float starNoise2 = fract(sin(dot(uv * 150.0 + 0.5, vec2(37.719, 89.123))) * 65432.123);
    float starNoise3 = fract(sin(dot(uv * 200.0 + 1.0, vec2(45.321, 67.890))) * 87654.321);
    
    // Combinar múltiples capas de estrellas
    float stars = 0.0;
    
    // Estrellas brillantes (pocas pero muy visibles)
    if (starNoise > 0.998) {
        stars = 1.0;
    }
    
    // Estrellas medianas (más frecuentes)
    if (starNoise2 > 0.995) {
        stars = max(stars, 0.7);
    }
    
    // Estrellas débiles (muchas)
    if (starNoise3 > 0.99) {
        stars = max(stars, 0.4);
    }
    
    // Parpadeo de estrellas
    float twinkle = sin(time * 2.0 + uv.x * 10.0 + uv.y * 5.0) * 0.3 + 0.7;
    stars *= twinkle;
    
    // Hacer que las estrellas sean más brillantes en el cenit
    float zenithFactor = smoothstep(-0.1, 0.5, direction.y);
    stars *= (1.0 + zenithFactor * 0.5);
    
    // Aplicar intensidad ajustable
    stars *= starIntensity;
    
    return stars;
}

void main() {
    // ===== SKYBOX =====
    if (isSkybox > 0.5) {
        vec3 dir = normalize(skyboxTexCoord);
        
        // Aplicar rotación alrededor del eje Y
        float cosRot = cos(skyboxRotation);
        float sinRot = sin(skyboxRotation);
        vec3 rotatedDir = vec3(
            cosRot * dir.x - sinRot * dir.z,
            dir.y,
            sinRot * dir.x + cosRot * dir.z
        );
        
        // Usar cielo procedural con nubes mejoradas
        vec3 skyColor = skyGradient(rotatedDir, uTime);
        
        // Añadir estrellas MUCHO más visibles
        float nightFactor = smoothstep(-0.1, 0.3, rotatedDir.y); // Más estrellas visibles
        if (nightFactor > 0.0) {
            // Generar campo de estrellas mejorado
            float stars = starField(rotatedDir, uTime);
            
            // Color de las estrellas (ligeramente azulado para mayor realismo)
            vec3 starColor = mix(vec3(1.0, 1.0, 1.0), vec3(0.8, 0.9, 1.0), 0.3);
            
            // Mezclar estrellas con el cielo - MUCHO más intenso
            float starIntensity = stars * nightFactor * 1.5; // Aumentar intensidad
            skyColor = mix(skyColor, starColor, starIntensity);
            
            // Añadir efecto de brillo alrededor de estrellas brillantes
            if (stars > 0.95) {
                float glow = smoothstep(0.95, 1.0, stars) * 0.3;
                skyColor += starColor * glow * nightFactor;
            }
        }
        
        // Añadir atardecer/anochecer (coloración rojiza en el horizonte)
        float sunset = smoothstep(0.0, 0.2, rotatedDir.y);
        vec3 sunsetColor = vec3(1.0, 0.6, 0.3);
        skyColor = mix(skyColor, sunsetColor, sunset * 0.3 * (0.5 + 0.5 * sin(uTime * 0.1)));
        
        fragmentColor = vec4(skyColor, 1.0);
        return;
    }

    // ===== OBJETOS NORMALES (cubo y agua) =====
    vec3 N = normalize(ecNormalOut);
    vec3 V = normalize(-ecPositionOut);
    vec3 L = normalize(Light.Position - ecPositionOut);

    vec3 litColor = phong(N, L, V);

    if (fogEnabled < 0.5) {
        fragmentColor = vec4(litColor, 1.0);
        return;
    }

    float dist = abs(ecPositionOut.z);

    // Niebla más dinámica
    float drift = ecPositionOut.x * 1.8 + ecPositionOut.y * 1.0 + uTime * 1.8;
    float bank = 0.5 + 0.5 * sin(drift);
    bank = pow(bank, 3.0);
    dist += bank * 2.5;

    float fogFactor;
    if (fogMode < 0.5) {
        fogFactor = (fogMax - dist) / (fogMax - fogMin);
    } else {
        float dnorm = clamp((dist - fogMin) / (fogMax - fogMin), 0.0, 1.0);
        fogFactor = exp(-pow(dnorm * 3.0, 2.0));
    }

    fogFactor = clamp(fogFactor, 0.0, 1.0);
    vec3 finalColor = mix(fogColor, litColor, fogFactor);
    fragmentColor = vec4(finalColor, 1.0);
}
    </script>

</head>

<body>
    <h2>Phong + Niebla + Agua + Skybox Mejorado</h2>
    <canvas id="glCanvas" width="600" height="600"></canvas>
    <div class="info">Arrastra con el ratón para rotar la cámara | Usa la rueda para zoom | Skybox con nubes y estrellas mejoradas</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
    <script src="app.js"></script>
</body>
</html>